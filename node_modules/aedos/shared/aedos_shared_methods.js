const { detectAll } = require("tinyld");
const strSim = require("string-similarity");
const getDirtyWordsListFromDB = require("./get_dirty_words");
const setProfanityLevel = require("./set_profanity");

class AedosUtility {
  supportedLanguages = {
    Africa: ["Amharic", "Berber", "Hausa", "Swahili"],
    Asia: [
      "Chinese",
      "Japanese",
      "Korean",
      "Indonesian",
      "Javanese",
      "Khmer",
      "Tagalog",
      "Thai",
      "Vietnamese",
      "Bengali",
      "Gujarati",
      "Hindi",
      "Kannada",
      "Marathi",
      "Tamil",
      "Telugu",
      "Urdu",
    ],
    Europe: [
      "Dutch",
      "English",
      "French",
      "German",
      "Italian",
      "Irish",
      "Latin",
      "Portuguese",
      "Spanish",
      "Danish",
      "Estonian",
      "Finnish",
      "Icelandic",
      "Latvian",
      "Lituanian",
      "Norwegian",
      "Swedish",
      "Bulgarian",
      "Czech",
      "Croatian",
      "Greek",
      "Hungarian",
      "Macedonian",
      "Serbian",
      "Slovak",
      "Slovenian",
      "Belarussian",
      "Polish",
      "Romanian",
      "Russian",
      "Turkish",
      "Ukrainian",
    ],
    MiddleEast: [
      "Arabic",
      "Hebrew",
      "Kabyle",
      "Persian",
      "Tatar",
      "Turkmen",
      "Uzbek",
    ],
  };
  #text;
  constructor(text) {
    this.#text = text;
  }

  async detectLanguagesInText() {
    try {
      const detectedLanguages = detectAll(this.#text);
      return {
        data: {
          "detected-languages": detectedLanguages,
          length: detectedLanguages.length,
          "original-text": this.#text,
          "text-length": this.#text.length,
          "supported-languages": this.supportedLanguages,
          "detected-at": new Date().toJSON(),
        },
      };
    } catch (e) {
      throw new Error("ServerError:" + e.message);
    }
  }

  async detectProfaneWordsInText() {
    const detectedLanguages = (await this.detectLanguagesInText(this.#text))
      .data["detected-languages"];

    let profaneWordsList;
    try {
      profaneWordsList = await getDirtyWordsListFromDB(detectedLanguages);
    } catch (e) {
      throw new Error("NetworkError: " + e.message);
    }

    const filterResult = strSim
      .findBestMatch(
        this.#text,
        profaneWordsList.map((e) => e.word)
      )
      .ratings.filter((e, i) =>
        this.#text.search(e.target) == -1 || e.rating == 0 ? null : e
      );

    return {
      data: {
        "original-text": this.#text,
        "founded-words": filterResult.map(
          (e) =>
            e.target.slice(0, 2) + e.target.slice(2).replace(/[A-z]*/gim, "*")
        ),
        "words-indexes": filterResult.map((e) => this.#text.search(e.target)),
        "is-profane": filterResult.length ? true : false,
        "detected-languages": detectedLanguages,
        "detected-at": new Date().toJSON(),
        "profanity-percent":
          (filterResult.length / this.#text.split(" ").length) * 100,

        "profanity-level": setProfanityLevel(
          (filterResult.length / this.#text.split(" ").length) * 100
        ),
      },
    };
  }

  async removeProfaneWordsFromText() {
    const wordIndexes = (await this.detectProfaneWordsInText(this.#text)).data[
      "words-indexes"
    ];

    if (!wordIndexes) return "text has no profane words to remove";

    return {
      originalText: this.#text,
      moderatedText: this.#text
        .split(" ")
        .filter((w) => (wordIndexes.includes(this.#text.search(w)) ? null : w)),
    };
  }
}

module.exports = AedosUtility;
